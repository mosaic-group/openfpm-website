<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="/img/openfpm.png">
        <meta name="keywords" content="Particle Methods Library,Particle Methods Code,Particle Methods C++,SPH C++,DC-PSE C++,Active Matter C++,Molecular Dynamics C++,Sparse Grid C++">
<!--	<title></title>  -->
        <title>OpenFPM - C++ framework for parallel particle-mesh codes</title>

        <link href="../css/bootstrap-mkdocs.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/highlight.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <!-- Main title -->
            <a class="navbar-brand" href="http://openfpm.mpi-cbg.de/">OpenFPM</a>
        </div>

        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li class="active">
                                 <a href="./">Vector</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li >
                                 <a href="../building/">Build from source</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../docker/">Docker</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="http://ppmcore.mpi-cbg.de/doxygen/openfpm/">Doxygen</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li >
                                 <a href="../news/">News</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../videos/">Videos</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../hackathon23/">Hackathon 2022/2023</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../hackathon24/">Hackathon 2023/2024</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li >
                    <!-- Replace "nav_item.url|url" with "nav_item.url" for older mkdocs (before 1.0) -->
                    <a href="../about/">Cite us</a>
                </li>
            
            
            
            
            
                <li >
                    <!-- Replace "nav_item.url|url" with "nav_item.url" for older mkdocs (before 1.0) -->
                    <a href="../download/">Download</a>
                </li>
            
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                
                <li>
                    <a href="https://github.com/mosaic-group/openfpm">
                        
                            <i class="fa fa-github-square"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        
        <div class="container">
            
            <div class="col-md-3 visible-xs visible-sm"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#examples-of-distributed-vector-usage">Examples of distributed vector usage</a></li>
        
            <li><a href="#vector-0-simple-vector-initialization">Vector 0: Simple vector initialization</a></li>
        
            <li><a href="#example-1-vector-ghost-layer">Example 1: Vector Ghost layer</a></li>
        
            <li><a href="#example-2-cell-lists-and-verlet-lists">Example 2: Cell-lists and Verlet-lists</a></li>
        
            <li><a href="#example-3-gpu-vector">Example 3: GPU vector</a></li>
        
            <li><a href="#example-4-hdf5-save-and-load">Example 4: HDF5 Save and load</a></li>
        
            <li><a href="#example-5-vector-expressions">Example 5: Vector expressions</a></li>
        
            <li><a href="#example-6-molecular-dynamics-with-lennard-jones-potential-cell-list">Example 6: Molecular Dynamics with Lennard-Jones potential (Cell-List)</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-verlet-list-13">Example 7: Molecular Dynamics with Lennard-Jones potential (Verlet-List) [1/3]</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-verlet-list-23">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric Verlet-List) [2/3]</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-crs-verlet-list-33">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric CRS Verlet-List) [3/3]</a></li>
        
            <li><a href="#example-8-molecular-dynamics-with-lennard-jones-potential-gpu">Example 8: Molecular Dynamics with Lennard-Jones potential (GPU)</a></li>
        
            <li><a href="#example-9-molecular-dynamics-with-lennard-jones-potential-gpu-optimized">Example 9: Molecular Dynamics with Lennard-Jones potential (GPU optimized)</a></li>
        
            <li><a href="#example-10-molecular-dynamics-with-lennard-jones-potential-particle-reordering">Example 10: Molecular Dynamics with Lennard-Jones potential (Particle reordering)</a></li>
        
            <li><a href="#example-11-molecular-dynamics-with-lennard-jones-potential-cell-list-reordering">Example 11: Molecular Dynamics with Lennard-Jones potential (Cell-list reordering)</a></li>
        
            <li><a href="#example-12-complex-properties-12">Example 12: Complex properties [1/2]</a></li>
        
            <li><a href="#example-13-complex-properties-22">Example 13: Complex properties [2/2]</a></li>
        
            <li><a href="#example-14-multiphase-cell-lists-and-verlet-lists">Example 14: Multiphase Cell-lists and Verlet-lists</a></li>
        
            <li><a href="#example-16-validation-and-debugging">Example 16: Validation and debugging</a></li>
        
            <li><a href="#example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-12">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU [1/2]</a></li>
        
            <li><a href="#example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-optimized-22">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU: optimized [2/2]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-13">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU [1/3]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-optimized-23">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: optimized [2/3]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-opetimized-33">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: opetimized [3/3]</a></li>
        
            <li><a href="#example-19-discrete-element-method-dem-simulation-of-the-avalanche-down-the-inclined-plane">Example 19: Discrete Element Method (DEM) simulation of the avalanche down the inclined plane</a></li>
        
            <li><a href="#example-20-gpu-cuda-interoperability">Example 20: GPU CUDA interoperability</a></li>
        
    
    
    </ul>
</div>

<!-- Developer notes:
  See the MkDocs documentation in https://www.mkdocs.org/dev-guide/themes/#page
  and the Jinja2 template API in https://tedboy.github.io/jinja2/index.html
--></div> <!-- toc on top on mobile -->
            <div class="col-md-9" role="main">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_HTML">
</script>

<h2 id="examples-of-distributed-vector-usage">Examples of distributed vector usage</h2>
<p><a id="ex0"></a></p>
<h3 id="vector-0-simple-vector-initialization">Vector 0: Simple vector initialization</h3>
<p>This example show several basic functionalities of the distributed vector <code>vector_dist</code>. 
The distributed vector is a set of particles in an N-dimensional space.
In this example it is shown how to:</p>
<ul>
<li>Initialize the library</li>
<li>Create a <code>Box</code> that defines the domain</li>
<li>An array that defines the boundary conditions</li>
<li>A <code>Ghost</code> object that will define the extension of the ghost part in physical units</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/0_simple/main.cpp">Vector/0_simple/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_0_simple.html">Vector_0_simple</a></em>.</p>
<p>See also our video lectures dedicated to this topic <a href="https://ppmcore.mpi-cbg.de/upload/video/Lesson1-1.mp4">Video 1</a>, <a href="https://ppmcore.mpi-cbg.de/upload/video/Lesson1-2.mp4">Video 2</a></p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex1"></a></p>
<h3 id="example-1-vector-ghost-layer">Example 1: Vector Ghost layer</h3>
<p><img class="floatright" src="https://ppmcore.mpi-cbg.de/web/images/examples/after_ghost_get.jpg" style="width: 300px; height: 300px;"></p>
<p>This example shows the properties of <code>ghost_get</code> and <code>ghost_put</code> - functions 
that synchronize the ghosts layer for a distributed vector <code>vector_dist</code>.</p>
<p>In this example it is shown how to:</p>
<ul>
<li>Iterate <code>vector_dist</code> via <code>getDomainIterator</code> </li>
<li>Redistribute the particles in <code>vector_dist</code> according to the underlying domain decomposition via <code>map</code></li>
<li>Synchronize the ghost layers in the standard way</li>
<li><code>NO_POSITION</code>, <code>KEEP_PROPERTIES</code> and <code>SKIP_LABELLING</code> options of the <code>ghost_get</code> function</li>
<li>Propagate the data from ghost to non-ghost particles via <code>ghost_put</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/1_ghost_get_put/main.cpp">Vector/1_ghost_get_put/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_1_ghost_get.html">Vector_1_ghost_get</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex2"></a></p>
<h3 id="example-2-cell-lists-and-verlet-lists">Example 2: Cell-lists and Verlet-lists</h3>
<p>This example shows the properties of <code>ghost_get</code> and <code>ghost_put</code> - functions 
that synchronize the ghosts layer for a distributed vector <code>vector_dist</code>.</p>
<p>Key points:</p>
<ul>
<li>How to utilize the grid iterator <code>getGridIterator</code>, to create a grid-like particle domain</li>
<li>Two principal types of fast neighbor lists: cell-list <code>getCellList</code> and Verlet-list <code>getVerlet</code> for a distributed vector <code>vector_dist</code></li>
<li><code>CELL_MEMFAST</code>, <code>CELL_MEMBAL</code> and <code>CELL_MEMMW</code> variations of the cell-list, with different memory requirements and computations costs</li>
<li>Iterating through the neighboring particles via <code>getNNIterator</code> of cell-list and Verlet-list</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/1_ghost_get_put/main.cpp">Vector/1_celllist/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_1_celllist.html">Vector_1_celllist</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex3"></a></p>
<h3 id="example-3-gpu-vector">Example 3: GPU vector</h3>
<p><img class="floatright" src="../img/examples/1_gpu_first_step.png" style="width: 300px; height: 300px;"></p>
<p>This example shows how to create a vector data-structure with <code>vector_dist_gpu</code> to access a <code>vector_dist</code>-alike data structure from GPU accelerated computing code.</p>
<p>Key points:</p>
<ul>
<li>How to convert the source code from using <code>vector_dist</code> to <code>vector_dist_gpu</code> and how it influences the memory layout of the data structure</li>
<li>Oflloading particle position <code>hostToDevicePos</code> and particle property <code>hostToDeviceProp</code> data from CPU to GPU</li>
<li>Lanuching a CUDA-like kernel with <code>CUDA_LAUNCH</code> and automatic subdivision of a computation loop into workgroups/threads via <code>getDomainIteratorGPU</code> or manually specifying the number of workgroups and the number of threads in a workgroup</li>
<li>Passing the data-structures to a CUDA-like kernel code via <code>toKernel</code></li>
<li>How to use <code>map</code> with the option <code>RUN_DEVICE</code> to redistribute the particles directly on GPU, and <code>ghost_get</code> with <code>RUN_DEVICE</code> option to fill ghost particles directly on GPU</li>
<li>How to detect and utilize RDMA on GPU to get the support of CUDA-aware MPI implementation to work directly with device pointers in communication subroutines</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/1_gpu_first_step/main.cpp">Vector/1_gpu_first_step/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_1_gpu_first_step.html">Vector_1_gpu_first_step</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex4"></a></p>
<h3 id="example-4-hdf5-save-and-load">Example 4: HDF5 Save and load</h3>
<p>This example show how to save and load a vector to/from the parallel file format HDF5.</p>
<p>Key points:</p>
<ul>
<li>How to save the position/property information of the particles <code>vector_dist</code> into an <em>.hdf5</em> file via <code>save</code></li>
<li>How to load the position/property information of the particles <code>vector_dist</code> from an <em>.hdf5</em> file via <code>load</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/tree/master/example/Vector/1_HDF5_save_load/main.cpp">Vector/1_HDF5_save_load/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_1_HDF5.html">Vector_1_HDF5</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex5"></a></p>
<h3 id="example-5-vector-expressions">Example 5: Vector expressions</h3>
<p>This example shows how to use vector expressions to apply mathematical operations and functions on particles. 
The example also shows to create a point-wise applicable function <br />
<script type="math/tex; mode=display"> A_q e^{\frac{|x_p-x_q|^2}{\sigma}} </script>
</p>
<p>where
$A_q$ is the property $A$ of particle $q$, $x_p, x_q$ are positions of particles $p, q$ correspondingly.</p>
<p>Key points:</p>
<ul>
<li>Setting an alias for particle properties via <code>getV</code> of <code>particle_dist</code> to be used within an expression </li>
<li>Composing expressions with scalar particle properties </li>
<li>Composing expressions with vector particle properties. The expressions are 1) applied point-wise; 2) used to create a component-wise multiplication via <code>*</code>; 3) scalar product via <code>pmul</code>; 4) compute a norm <code>norm</code>; 5) perform square root operation <code>sqrt</code></li>
<li>Converting <code>Point</code> object into an expression <code>getVExpr</code> to be used with vector expressions</li>
<li>Utilizing <code>operator=</code> and the function <code>assign</code> to assing singular or multiple particle properties per iteration through particles</li>
<li>Constructing expressions with <code>applyKernel_in</code> and <code>applyKernel_in_gen</code> to create kernel functions called at particle locations 
for all the neighboring particles, e.g. as in SPH</li>
</ul>
<p>
<script type="math/tex; mode=display">\sum_{q = Neighborhood(p)}  A_q D^{\beta}ker(x_p,x_q) V_q </script>
</p>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/tree/master/example/Vector/2_expressions/main.cpp">Vector/2_expressions/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_2_expression.html">Vector_2_expression</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex6"></a></p>
<h3 id="example-6-molecular-dynamics-with-lennard-jones-potential-cell-list">Example 6: Molecular Dynamics with Lennard-Jones potential (Cell-List)</h3>
<p>This example shows a simple Lennard-Jones molecular dynamics simulation in a stable regime. 
The particles interact with the interaction potential <br />
<script type="math/tex; mode=display"> V(x_p,x_q) = 4( (\frac{\sigma}{r})^{12} - (\frac{\sigma}{r})^6  ) </script>
</p>
<p>$A_q$ is the property $A$ of particle $q$, $x_p, x_q$ are positions of particles $p, q$ correspondingly, $\sigma$ is a free parameter, $r$ is the distance between the particles.</p>
<p>Key points:</p>
<ul>
<li>Reusing memory allocated with <code>getCellList</code> for the subsequent iterations via <code>updateCellList</code></li>
<li>Utilizing <code>CELL_MEMBAL</code> with <code>getCellList</code> to minimize memory footprint</li>
<li>Performing 10000 time steps using symplectic Verlet integrator</li>
</ul>
<p>
<script type="math/tex; mode=display"> \vec{v}(t_{n}+1/2) = \vec{v}_p(t_n) + \frac{1}{2} \delta t \vec{a}(t_n) </script>
</p>
<p>
<script type="math/tex; mode=display"> \vec{x}(t_{n}+1) = \vec{x}_p(t_n) + \delta t \vec{v}(t_n+1/2) </script>
</p>
<p>
<script type="math/tex; mode=display"> \vec{v}(t_{n+1}) = \vec{v}_p(t_n+1/2) + \frac{1}{2} \delta t \vec{a}(t_n+1) </script>
</p>
<ul>
<li>Producing a time-total energy 2D plot with <code>GoogleChart</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/3_molecular_dynamic/main.cpp">Vector/3_molecular_dynamic/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_3_md_dyn.html">Vector_3_md_dyn</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex7a"></a></p>
<h3 id="example-7-molecular-dynamics-with-lennard-jones-potential-verlet-list-13">Example 7: Molecular Dynamics with Lennard-Jones potential (Verlet-List) [1/3]</h3>
<p>The physical model in the example is identical to <a href="#ex6">Molecular Dynamics with Lennard-Jones potential (Cell-List)</a>. Please refer to it for futher details.
Key points:</p>
<ul>
<li>Due to the computational cost of updating Verlet-list, <em>r_cut + skin</em> cutoff distance is used
such that the Verlet-list has to be updated once in 10 iterations via <code>updateVerlet</code></li>
<li>As Verlet-lists are constructed based on local particle id's, which would be invalidated by <code>map</code> or <code>ghost_get</code> ,<code>map</code> is called every 10 time-step, and <code>ghost_get</code> is used with <code>SKIP_LABELLING</code> option to keep old indices every iteration</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/3_molecular_dynamic/main_vl.cpp">Vector/3_molecular_dynamic/main_vl.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_3_md_vl.html">Vector_3_md_vl</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex7b"></a></p>
<h3 id="example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-verlet-list-23">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric Verlet-List) [2/3]</h3>
<p>This example is an extension to <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a>. It shows how better performance can be achieved for symmetric interaction models with symmetric Verlet-list compared to the standard Verlet-list.
Key points:</p>
<ul>
<li>Computing the interaction for particles <em>p</em>, <em>q</em> only once</li>
<li>Propagate the data from potentially ghost particles <em>q</em> to non-ghost particles in their corresponding domains via <code>ghost_put</code> with the operation <code>add_</code></li>
<li>Changing the prefactor in the subroutine of calculating the total energy as every pair of particles is visited once (as compared to two times before) </li>
<li>Updating Verlet-list once in 10 iterations via <code>updateVerlet</code> with 'VL_SYMMETRIC' flag</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/5_molecular_dynamic_sym/main.cpp">Vector/5_molecular_dynamic_sym/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_5_md_vl_sym.html">Vector_5_md_vl_sym</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex7c"></a></p>
<h3 id="example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-crs-verlet-list-33">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric CRS Verlet-List) [3/3]</h3>
<p>This example is an extension to <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a> and <a href="#ex7b">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a>. It shows how better performance can be achieved for symmetric interaction models with symmetric Verlet-list compared to the standard Verlet-list.
Key points:</p>
<ul>
<li>Computing the interaction for particles <em>p</em>, <em>q</em> only once</li>
<li>Propagate the data from potentially ghost particles <em>q</em> to non-ghost particles in their corresponding domains via <code>ghost_put</code> with the operation <code>add_</code></li>
<li>Changing the prefactor in the subroutine of calculating the total energy as every pair of particles is visited once (as compared to two times before) </li>
<li>Updating Verlet-list once in 10 iterations via <code>updateVerlet</code> with 'VL_SYMMETRIC' flag</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/5_molecular_dynamic_sym/main.cpp">Vector/5_molecular_dynamic_sym/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_5_md_vl_sym.html">Vector_5_md_vl_sym</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex8"></a></p>
<h3 id="example-8-molecular-dynamics-with-lennard-jones-potential-gpu">Example 8: Molecular Dynamics with Lennard-Jones potential (GPU)</h3>
<p>The physical model in the example is identical to <a href="#ex6">Molecular Dynamics with Lennard-Jones potential (Cell-List)</a> and <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a>. Please refer to those for futher details.
Key points:</p>
<ul>
<li>To get the particle index inside a CUDA-like kernel <code>GET_PARTICLE</code> macro is used to avoid overflow in the construction <code>blockIdx.x * blockDim.x + threadIdx.x</code></li>
<li>A primitive reduction function <code>reduce_local</code> with the operation <code>_add_</code> is used to get the total energy by summing energies of all particles.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/3_molecular_dynamic_gpu/main.cu">Vector/3_molecular_dynamic_gpu/main_vl.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_3_md_dyn_gpu.html">Vector_3_md_dyn_gpu</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex9"></a></p>
<h3 id="example-9-molecular-dynamics-with-lennard-jones-potential-gpu-optimized">Example 9: Molecular Dynamics with Lennard-Jones potential (GPU optimized)</h3>
<p>The physical model in the example is identical to <a href="#ex6">Molecular Dynamics with Lennard-Jones potential (Cell-List)</a>, <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a> and is based on <a href="#ex8">Molecular Dynamics with Lennard-Jones potential (GPU)</a>. Please refer to those for futher details.
Key points:</p>
<ul>
<li>To achieve coalesced memory access on GPU and to reduce cache load the particle indices are stored in cell-list in a sorted manner, i.e. particles with neighboring indices are located in the same cell. This is achieved by assigning new particle indices and storing them temporarily in <code>vector_dist</code> by passing the parameter <code>CL_GPU_REORDER</code> to the method <code>getCellListGPU</code> of <code>vector_dist</code>. By default the method copies particle positions and no properties to the reordered vector. To copy properties as well they are passed as a template parameter <code>&lt;...&gt;</code> of the method <code>getCellListGPU</code>.</li>
<li>The cell-list built on top of the reordered version of <code>vector_dist</code> uses <code>get_sort</code> instead of <code>get</code> to get a neighbor particle index when iterating with the cell-list neighborhood iterator <code>getNNIteratorBox</code></li>
<li>The sorted version of <code>vector_dist</code> have to be reordered to the original order once the processing is done via <code>restoreOrder</code> of <code>vector_dist</code>. By default the method copies particle positions and no properties to the original unordered vector. To copy properties as well they are passed as a template parameter <code>&lt;...&gt;</code> of the method <code>restoreOrder</code>.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/3_molecular_dynamic_gpu_opt/main_gpu.cu">Vector/3_molecular_dynamic_gpu_opt/main_vl.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_3_md_dyn_gpu_opt.html">Vector_3_md_dyn_gpu_opt</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex10"></a></p>
<h3 id="example-10-molecular-dynamics-with-lennard-jones-potential-particle-reordering">Example 10: Molecular Dynamics with Lennard-Jones potential (Particle reordering)</h3>
<p>The physical model in the example is identical to <a href="#ex6">Molecular Dynamics with Lennard-Jones potential (Cell-List)</a>, <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a>. The example shows how reordering the data can significantly reduce the computational running time. 
Key points:</p>
<ul>
<li>The particles inside <code>vector_dist</code> are reordered via <code>reorder</code> following a Hilbert curve of order <em>m</em> (here <em>m=5</em>) passing through the cells of $2^m \times 2^m \times 2^m$ (here, in 3D) cell-list</li>
<li>It is shown that the frequency of reordering depends on the mobility of particles</li>
<li>Wall clock time is measured of the function <code>calc_force</code> utilizing the object <code>timer</code> via <code>start</code> and <code>stop</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/4_reorder/main_data_ord.cpp">Vector/4_reorder/main_data_ord.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_4_reo.html">Vector_4_reo</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex11"></a></p>
<h3 id="example-11-molecular-dynamics-with-lennard-jones-potential-cell-list-reordering">Example 11: Molecular Dynamics with Lennard-Jones potential (Cell-list reordering)</h3>
<p>The physical model in the example is identical to <a href="#ex6">Molecular Dynamics with Lennard-Jones potential (Cell-List)</a>, <a href="#ex7a">Molecular Dynamics with Lennard-Jones potential (Verlet-List)</a>. The example shows how reordering the data can significantly reduce the computational running time. 
Key points:</p>
<ul>
<li>The cell-list cells are iterated following a Hilbert curve instead of a normal left-to-right bottom-to-top cell iteration (in 2D). The function <code>getCellList_hilb</code> of <code>vector_dist</code> is used instead of <code>getCellList</code></li>
<li>It is shown that for static or slowly moving particles a speedup of up to 10% could be achieved</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/4_reorder/main_comp_ord.cpp">Vector/4_reorder/main_comp_ord.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_4_comp_reo.html">Vector_4_comp_reo</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex12"></a></p>
<h3 id="example-12-complex-properties-12">Example 12: Complex properties [1/2]</h3>
<p>This example shows how to use complex properties in the distributed vector <code>vector_dist</code></p>
<p>Key points:</p>
<ul>
<li>Creating a distributed vector with particle properties: scalar, vector <code>float[3]</code>, <code>Point</code>, list of float <code>openfpm::vector&lt;float&gt;</code>, list of custom structures <code>openfpm::vector&lt;A&gt;</code> (where <code>A</code> is a user-defined type with no pointers), vector of vectors <code>openfpm::vector&lt;openfpm::vector&lt;float&gt;&gt;&gt;</code></li>
<li>Redistribute the particles in <code>vector_dist</code> according to the underlying domain decomposition. Communicate only the selected particle properties via <code>map_list</code> (instead of communicating all <code>map</code>)</li>
<li>Synchronize the ghost layers only for the selected particle properties <code>ghost_get</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/4_complex_prop/main.cpp">Vector/4_complex_prop/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_4_complex_prop.html">Vector_4_complex_prop</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex13"></a></p>
<h3 id="example-13-complex-properties-22">Example 13: Complex properties [2/2]</h3>
<p>This example shows how to use complex properties in the distributed vector <code>vector_dist</code></p>
<p>Key points:</p>
<ul>
<li>Creating a distributed vector with particle properties: scalar, vector <code>float[3]</code>, <code>Point</code>, list of float <code>openfpm::vector&lt;float&gt;</code>, list of custom structures <code>openfpm::vector&lt;A&gt;</code> (where <code>A</code> is a user-defined type with memory pointers inside), vector of vectors <code>openfpm::vector&lt;openfpm::vector&lt;float&gt;&gt;&gt;</code></li>
<li>Enabling the user-defined type being serializable by <code>vector_dist</code> via <ul>
<li><code>packRequest</code> method to indicate how many byte are needed to serialize the structure</li>
<li><code>pack</code> method to serialize the data-structure via methods <code>allocate</code>, <code>getPointer</code> of <code>ExtPreAlloc</code> and method <code>pack</code> of <code>Packer</code> </li>
<li><code>unpack</code> method to deserialize the data-structure via method <code>getPointerOffset</code> of <code>ExtPreAlloc</code> and method <code>unpack</code> of <code>Unpacker</code></li>
<li><code>noPointers</code> method to inform the serialization system that the object has pointers</li>
<li>Constructing constructor, destructor and <code>operator=</code> to avoid memory leaks </li>
</ul>
</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/4_complex_prop/main.cpp">Vector/4_complex_prop/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_4_complex_prop_ser.html">Vector_4_complex_prop_ser</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex14"></a></p>
<h3 id="example-14-multiphase-cell-lists-and-verlet-lists">Example 14: Multiphase Cell-lists and Verlet-lists</h3>
<p>This example is an extension to <a href="#ex2">Example 2: Cell-lists and Verlet-lists</a> and ()[]. It shows how to use multi-phase cell-lists and Verlet-list using multiple instances of <code>vector_dist</code>. Key points:</p>
<ul>
<li>All the phases have to use the same domain decomposition, which is achieved by passing the decomposition of the first phase to the constructor of <code>vector_dist</code> of all the other phases.</li>
<li>The domains have to be iterated individually via <code>getDomainIterator</code>, the particles redistributed via <code>map</code>, the ghost layers synchronized via <code>ghost_get</code> for all the phases <code>vector_dist</code>.</li>
<li>Constructing Verlet-lists for two phases (<em>ph0</em>, <em>ph1</em>) with <code>createVerlet</code>, where for one phase <em>ph0</em> the neighoring particles of <em>ph1</em> are assigned in the Verlet-list. Cell-list of <em>ph1</em> has to be passed to <code>createVerlet</code></li>
<li>Constructing Verlet-lists for multiple phases (<em>ph0</em>, <em>ph1</em>, <em>ph2</em>...) with <code>createVerletM</code>, where for one phase <em>ph0</em> the neighoring particles of <em>ph1</em>, <em>ph2</em>... are assigned in the Verlet-list. Cell-list containing all of <em>ph1</em>, <em>ph2</em>... create with <code>createCellListM</code> has to be passed to <code>createVerletM</code></li>
<li>Iterating over the neighboring particles of a multiphase Verlet-list with <code>getNNIterator</code> with <code>get</code> being substituded by <code>getP</code> (particle phase) and <code>getV</code> (particle id)</li>
<li>Extending example of the symmetric interaction for multiphase cell-lists and Verlet-lists via <code>createCellListSymM</code>, <code>createVerletSymM</code></li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/4_multiphase_celllist_verlet/main.cpp">Vector/4_multiphase_celllist_verlet/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_4_mp_cl.html">Vector_4_mp_cl</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex16"></a></p>
<h3 id="example-16-validation-and-debugging">Example 16: Validation and debugging</h3>
<p>This example shows how the flexibility of the library can be used to perform complex tasks for validation and debugging.
Key points:</p>
<ul>
<li>To get unique global id's of the particles the function <code>accum</code> of <code>vector_dist</code> is used, which returns prefix sum of local domain sizes $j&lt;i$ for the logical processor $i$ out of $N$ total processors</li>
<li>Propagate the data from potentially ghost particles <em>q</em> to non-ghost particles in their corresponding domains via <code>ghost_put</code> with the operation <code>merge_</code>, that merges two <code>openfpm::vector</code> (ghost and non-ghost)</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/6_complex_usage/main.cpp">Vector/6_complex_usage/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_6_complex_usage.html">Vector_6_complex_usage</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex17a"></a></p>
<h3 id="example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-12">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU [1/2]</h3>
<p>This example shows the classical SPH Dam break simulation with Load Balancing and Dynamic load balancing. The example has been adopted from <a href="https://github.com/DualSPHysics/DualSPHysics/wiki/3.-SPH-formulation">DualSPHysics</a>. Please refer to the website of <a href="https://github.com/DualSPHysics/DualSPHysics/wiki/3.-SPH-formulation">DualSPHysics</a> and to the paper of <a href="https://ui.adsabs.harvard.edu/abs/1992ARA&amp;A..30..543M">Monaghan, 1992</a> for more details. </p>
<p><img alt="SPH Dam break simulation" src="https://ppmcore.mpi-cbg.de/web/images/examples/7_SPH_dlb/dam_break_all.jpg" title="SPH Dam break" /></p>
<h4 id="formulation">Formulation</h4>
<p>The SPH formulation used in this example code follow these equations
<script type="math/tex; mode=display"> \frac{d\vec{v}_a}{dt} = - \sum_{b = NN(a) } m_b \left(\frac{P_a + P_b}{\rho_a \rho_b} + \Pi_{ab} \right) \nabla_{a} W_{ab} + g  </script>
<script type="math/tex; mode=display">\frac{d\rho_a}{dt} =  \sum_{b = NN(a) } m_b vec{v}_{ab} \cdot \nabla_{a} W_{ab} </script>
<script type="math/tex; mode=display"> P_a = b \left[ \left( \frac{\rho_a}{\rho_{0}} \right)^{\gamma} - 1 \right] </script>
</p>
<p>with the the viscosity term </p>
<p>
<script type="math/tex; mode=display"> \Pi_{ab} =  \begin{cases} - \frac{\alpha \bar{c_{ab}} \mu_{ab} }{\bar{\rho_{ab}} } & vec{v}_{ab} \cdot r_{ab} > 0 \\ 0 & vec{v}_{ab} \cdot r_{ab} < 0 \end{cases} </script>
</p>
<p>and the constants defined as</p>
<p>
<script type="math/tex; mode=display"> b = \frac{c_{s}^{2} \rho_0}{\gamma} </script>
<script type="math/tex; mode=display"> c_s = \sqrt{g \cdot h_{swl}} </script>
</p>
<p>The cubic kernel $W_{ab}$ defined as</p>
<p>
<script type="math/tex; mode=display"> \begin{cases} 1.0 - \frac{3}{2} q^2 + \frac{3}{4} q^3 & 0 < q < 1 \\ (2 - q)^3 & 1 < q < 2 \\ 0 & q > 2 \end{cases} </script>
</p>
<p>its gradient $ \nabla W_{ab} $.</p>
<p>
<script type="math/tex; mode=display"> \nabla W_{ab} = \beta (x,y,z) </script>
</p>
<p>
<script type="math/tex; mode=display"> \beta = \begin{cases} (c_1 q + d_1 q^2) & 0 < q < 1 \\ c_2 (2 - q)^2 & 1 < q < 2 \end{cases} </script>
</p>
<p>While the particle kernel support is given by</p>
<p>
<script type="math/tex; mode=display"> H = \sqrt{3 \cdot dp} </script>
</p>
<p>where $dp$ is the particle spacing. Please refer to the work of <a href="https://ui.adsabs.harvard.edu/abs/1992ARA&amp;A..30..543M">Monaghan, 1992</a> for more details on the variables and constants used.</p>
<p>The simulation uses an additional Tensile term to avoid the tensile instability. Please refer to <a href="https://www.sciencedirect.com/science/article/pii/S0021999100964398">Monaghan, 1999</a> for more details on this scheme.</p>
<h4 id="time-stepping">Time-stepping</h4>
<p>Dynamic time stepping is calculated in accordance with <a href="https://ui.adsabs.harvard.edu/abs/1992ARA&amp;A..30..543M">Monaghan, 1992</a></p>
<p>
<script type="math/tex; mode=display"> \delta t = CFL \cdot min(t_f,t_{cv}) </script>
</p>
<p>where</p>
<p>
<script type="math/tex; mode=display"> \delta t_f = min \sqrt{h/\vec{f_a}} </script>
</p>
<p>
<script type="math/tex; mode=display"> \delta t_{cv} = min \frac{h}{c_s + max \left| \frac{hv_{ab} \cdot r_{ab}}{r_{ab}^2} \right|} </script>
</p>
<p>With the governing equations are written as</p>
<p>
<script type="math/tex; mode=display"> \frac{\vec{v}_a^{n+1}}{dt} = \vec{F_a} </script>
</p>
<p>
<script type="math/tex; mode=display"> \frac{\rho_a^{n+1}}{dt} = D_a </script>
</p>
<p>
<script type="math/tex; mode=display"> \frac{\vec{r}_a^{n+1}}{dt} = \vec{v}_a </script>
</p>
<p>The Verlet time-stepping scheme <a href="https://journals.aps.org/pr/abstract/10.1103/PhysRev.159.98">Verlet, 1967</a> is used</p>
<p>
<script type="math/tex; mode=display"> \vec{v}_a^{n+1} = \vec{v}_a^{n-1} + 2 \delta t \vec{F_a}^{n} </script>
</p>
<p>
<script type="math/tex; mode=display"> \vec{r}_a^{n+1} = \delta t \vec{r}_a^n + \delta t \vec{v}_a^{n} + 0.5 \delta t^2 \vec{F_a}^n </script>
</p>
<p>
<script type="math/tex; mode=display"> \rho_a^{n+1} = \rho_a^{n-1} + 2 \delta t D_a^n </script>
</p>
<p>Due to the integration over a staggered time interval, the equations of density and velocity are decoupled, which may lead to divergence of the integrated values. See <a href="https://github.com/DualSPHysics/DualSPHysics/wiki/3.-SPH-formulation">DualSPHysics</a> formulation.</p>
<p>
<script type="math/tex; mode=display"> \vec{v}_a^{n+1} = \vec{v}_a^{n} + \delta t \vec{F_a}^n </script>
</p>
<p>
<script type="math/tex; mode=display"> \vec{r}_a^{n+1} = \vec{r}_a^{n} + \delta t \vec{v}_a^n + \frac{1}{2} \delta t^2 \vec{F_a}^n </script>
</p>
<p>
<script type="math/tex; mode=display"> \rho_a^{n+1} = \rho_a^n + \delta t D_a^n </script>
</p>
<h4 id="load-balancing">Load Balancing</h4>
<p><img alt="Domain decomposition multi-colored subdomains" src="https://ppmcore.mpi-cbg.de/web/images/examples/7_SPH_dlb/unbalanced_particles.jpg" title="Domain decomposition" /></p>
<p>In order to reach an optimal utilization of available computational resource we distribute the particles to reach a balanced simulation. To do this we set weights for each sub-sub-domain, decompose the space and distribute the particles accordingly. </p>
<p>The weights are set according to:</p>
<p>
<script type="math/tex; mode=display"> w_v = 4 N_{fluid} + 3 N_{boundary} </script>
</p>
<p>where $N_{fluid}$ Is the number of fluid particles in a sub-sub-domain and $ N_{boundary} $ is the number of boundary particles.</p>
<p>Implicitly the communication cost is given by $ \frac{V_{ghost}}{V_{sub-sub}} t_s $, while the migration cost is given by $ v_{sub-sub} $. In general $ t_s $ is the number of <code>ghost_get</code> calls between two rebalance calls.</p>
<p><a href="https://openfpm.mpi-cbg.de/upload/video/dlb-1.mp4">Dynamic load balancing. Theory 1</a><br />
<a href="https://openfpm.mpi-cbg.de/upload/video/dlb-2.mp4">Dynamic load balancing. Theory 2</a><br />
<a href="https://openfpm.mpi-cbg.de/upload/video/dlb-3.mp4">Dynamic load balancing. Practice 1</a><br />
<a href="https://openfpm.mpi-cbg.de/upload/video/dlb-4.mp4">Dynamic load balancing. Practice 2</a><br /></p>
<h4 id="simulation-results">Simulation results</h4>
<p><a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_speed.mp4">Simulation video 1</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_speed2.mp4">Simulation video 2</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_dlb.mp4">Simulation dynamic load balancing video 1</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_dlb2.mp4">Simulation dynamic load balancing video 2</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_zoom.mp4">Simulation countour prospective 1</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_back.mp4">Simulation countour prospective 2</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_all.mp4">Simulation countour prospective 3</a><br /></p>
<p>Key points:</p>
<ul>
<li>Load balancing and dynamic load balancing indicate the possibility of the system to re-adapt the domain decomposition to keep all the processor under load and reduce idle time</li>
<li>Cell-list is used to iterate neighboring particles when computing derivatives</li>
<li>Domain decomposition could use a user-provided cost function on <em>sub-sub-domains</em> later for them to be assigned to <em>sub-domains</em> (usually equal to the number of processors) via <code>addComputationCosts</code> of <code>vector_dist</code></li>
<li>The object <code>DEC_GRAN(512)</code> passed to the constructor of <code>vector_dist</code> is related to the Load-Balancing decomposition granularity. It indicates that the space must be decomposed in at least $ N_{subsub} $ <em>sub-sub-domains</em> for $ N_p $ processors</li>
</ul>
<p>
<script type="math/tex; mode=display"> N_{subsub} = 512 \cdot N_p </script>
</p>
<ul>
<li>Method <code>DrawBox</code> of the class <code>DrawParticles</code> returns an iterator that can be used to create particles on a Cartesian grid with a given spacing (grid boundaries should be inside the simulation domain).</li>
<li>After filling the computational cost the domain stored in <code>vector_dist</code> is decomposed via <code>getDecomposition().decompose()</code> (i.e. every sub-sub-domain is assigned to a processor) and subsequently the particles are redistributed to the corresponding processors via <code>map</code>.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/7_SPH_dlb/main.cpp">Vector/7_SPH_dlb/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_7_sph_dlb.html">Vector_7_sph_dlb</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex17b"></a></p>
<h3 id="example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-optimized-22">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU: optimized [2/2]</h3>
<p>The physical model in the example is identical to <a href="#ex17a">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU</a>.</p>
<p>Key points:</p>
<ul>
<li>Verlet-list is used instead of Cell list to iterate neighboring particles when computing derivatives. The Verlet-list is reconstructed on maximum particle displacement reaching the half skin size. Symmetric interaction reduces the computation complexity by half. Ghost particles are used to store symmetric interaction force and density increments. The increments are added to the corresponding non-ghost particles via <code>ghost_put</code></li>
<li><code>vector_dist</code> is constructed with the option <code>BIND_DEC_TO_GHOST</code>. It binds the domain decomposition to be multiple of the ghost size required by the symmetric interaction</li>
<li>Refine the domain decomposition instead of decomposing the domain from scratch via <code>getDecomposition().redecompose(...)</code> of <code>vector_dist</code>. Available only for ParMetis decomposition.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/7_SPH_dlb/main.cpp">Vector/7_SPH_dlb_opt/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_7_sph_dlb_opt.html">Vector_7_sph_dlb_opt</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex18a"></a></p>
<h3 id="example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-13">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU [1/3]</h3>
<p>The physical model in the example is identical to <a href="#ex18a">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU</a> with the computation-heavy subroutines being executed on GPU.</p>
<h4 id="simulation-results_1">Simulation results</h4>
<p><a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_gpu1.mp4">Simulation video 1</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_gpu2.mp4">Simulation video 2</a><br />
<a href="https://openfpm.mpi-cbg.de/web/images/examples/7_SPH_dlb/sph_gpu3.mp4">Simulation video 3</a><br /></p>
<p>Key points:</p>
<ul>
<li>Derivative approximation scheme (SPH), particle force calculation, time integration schemes (Euler, Verlet time integration) and pressure sensor readings implemented on GPU.</li>
<li>A primitive reduction function <code>reduce_local</code> with the operation <code>_add_</code> is used to get the total energy by summing energies of all particles.</li>
<li>Particles exceeding the domain boundaries are removed with the GPU subroutine <code>remove_marked&lt;prp&gt;</code>, where <code>prp</code> is the property of <code>vector_dist</code> set to 1 for particles to be removed, and to 0 otherwise.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/7_SPH_dlb_gpu/main.cu">Vector/7_SPH_dlb_gpu/main.cu</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_7_sph_dlb_gpu.html">Vector_7_sph_dlb_gpu</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex18b"></a></p>
<h3 id="example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-optimized-23">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: optimized [2/3]</h3>
<p>The physical model in the example is identical to <a href="#ex18a">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU</a> with the computation-heavy subroutines being executed on GPU optimized for improved coalesced memory access.</p>
<p>Key points:</p>
<ul>
<li>To achieve coalesced memory access on GPU and to reduce cache load the particle indices are stored in cell-list in a sorted manner, i.e. particles with neighboring indices are located in the same cell. This is achieved by assigning new particle indices and storing them temporarily in <code>vector_dist</code> by passing the parameter <code>CL_GPU_REORDER</code> to the method <code>getCellListGPU</code> of <code>vector_dist</code>. By default the method copies particle positions and no properties to the reordered vector. To copy properties as well they are passed as a template parameter <code>&lt;...&gt;</code> of the method <code>getCellListGPU</code>.</li>
<li>The cell-list built on top of the reordered version of <code>vector_dist</code> uses <code>get_sort</code> instead of <code>get</code> to get a neighbor particle index when iterating with the cell-list neighborhood iterator <code>getNNIteratorBox</code></li>
<li>The sorted version of <code>vector_dist</code> have to be reordered to the original order once the processing is done via <code>restoreOrder</code> of <code>vector_dist</code>. By default the method copies particle positions and no properties to the original unordered vector. To copy properties as well they are passed as a template parameter <code>&lt;...&gt;</code> of the method <code>restoreOrder</code>.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/7_SPH_dlb_gpu_opt/main.cu">Vector/7_SPH_dlb_gpu_opt/main.cu</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_7_sph_dlb_gpu_opt.html">Vector_7_sph_dlb_gpu_opt</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex18c"></a></p>
<h3 id="example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-opetimized-33">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: opetimized [3/3]</h3>
<p>The physical model in the example is identical to <a href="#ex18b">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: optimized</a> with the computation-heavy subroutines being executed on GPU optimized for improved coalesced memory access and particle force calculation performed in 2 steps. </p>
<p>Key points:</p>
<ul>
<li>The subroutine <code>get_indexes_by_type</code> is used to split the particles into 2 lists of fluid and boundary particle ids. Two sets of GPU kernels are devised to calculate forces and density change separately for these two types of particles. </li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/7_SPH_dlb_gpu_more_opt/main.cu">Vector/7_SPH_dlb_gpu_more_opt/main.cu</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_7_sph_dlb_gpu_more_opt.html">Vector_7_sph_dlb_gpu_opt</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex19"></a></p>
<h3 id="example-19-discrete-element-method-dem-simulation-of-the-avalanche-down-the-inclined-plane">Example 19: Discrete Element Method (DEM) simulation of the avalanche down the inclined plane</h3>
<p>This example implements a Discrete Element Method (DEM) simulation using the Lorentz-force contact model.</p>
<p><img alt="Discrete Element Method (DEM) simulation of the avalanche down the inclined plane" src="https://ppmcore.mpi-cbg.de/web/images/examples/8_DEM/DEM_60.png" title="DEM simulation" /></p>
<p>A classical model for DEM simulations of spherical granular flows is the Silbert model,
it includes a Herzian contact force and an elastic deformation of the grains. Each particles
has a radius $R$, mass $m$, polar momentum $I$ and is represented by the location of its center of mass $r_{i}$.</p>
<p>When two particles $i$ and $j$ collide or are in contact, the elastic contact deformation is given by:</p>
<p>
<script type="math/tex; mode=display">\delta_{ij} = 2R-r_{ij}</script>
</p>
<p>where $\vec{r_{ij}}$ is the distance vector connecting particle centers and $r_{ij} = {\lvert \vec{r}_{ij}\rvert}_2$ its module.
The normal and tangential components of the relative velocity at the point of contact is given by</p>
<p>
<script type="math/tex; mode=display">\vec{v}_{n_{ij}} = \left(\vec{v}_{ij}\cdot\vec{n}_{ij}\right)\vec{n}_{ij}</script>
<script type="math/tex; mode=display">\vec{v}_{t_{ij}} = \vec{v}_{ij}-\vec{v}_{n_{ij}}-R\left(\vec{\omega}_i + \vec{\omega}_j \right)\times \vec{n}_{ij} </script>
</p>
<p>with $\vec{n_{ij}}=\vec{r_{ij}}/r_{ij}$ is the normal unit vector in direction of the distance vector,
$\vec{\omega_i}$ is the angular velocity of a particle and $\vec{v_{ij}}=\vec{v_i}-\vec{v_j}$ the relative velocity between the two
particles. The evolution of the elastic tangential displacement $\vec{u_{t_{ij}}}$ is integrated when two particles are in contact using:</p>
<p>
<script type="math/tex; mode=display">\vec{u'}_{t_{ij}} = \vec{u}_{t_{ij}} + \vec{v}_{t_{ij}} \delta t</script>
</p>
<p>Where $\delta t$ is the time step size. The deformation of the contacts points is stored for each particle and for each new contact
 point the elastic tangential displacement is initialized with $\vec{u_{t_{ij}}} = 0$. Thus for each pair of particle interacting
the normal and tangential forces become:</p>
<p>
<script type="math/tex; mode=display">\vec{F}_{n_{ij}}=\sqrt{\frac{\delta_{ij}}{2R}}\,\,\left(k_n\delta_{ij}\vec{n}_{ij}-\gamma_n
m_{\text{eff}}\vec{v}_{n_{ij}}\right) \, ,</script>
<script type="math/tex; mode=display">\vec{F}_{t_{ij}}=\sqrt{\frac{\delta_{ij}}{2R}}\,\,\left(-k_t\vec{u}_{t_{ij}}-\gamma_t
m_{\text{eff}}\vec{v}_{t_{ij}}\right) \, ,</script>
</p>
<p>where $k_{n,t}$ are the elastic constants in normal and tangential direction,
respectively, and $\gamma_{n,t}$ the corresponding viscoelastic constants. The
effective collision mass is given by $m_{\text{eff}}=\frac{m}{2}$. For each
contact point in order to enforce Coulomb's law </p>
<p>
<script type="math/tex; mode=display">\|\vec{F}_{t_{ij}}\|_2 < \|\mu\vec{F}_{n_{ij}}\|_2</script>
</p>
<p>the tangential force is bounded by the normal component force. In particular the elastic tangential displacement $\vec{u_{t_{ij}}}$ is
adjusted with</p>
<p>
<script type="math/tex; mode=display">\vec{F}_{t_{ij}} \leftarrow \vec{F}_{t_{ij}}\frac{\|\mu\vec{F}_{n_{ij}}\|_2}{\|\vec{F}_{t_{ij}}\|_2}</script>
</p>
<p>This adjustment induce a truncation of the elastic displacement. The Coulomb condition
is equivalent to the case where two spheres slip against each other without
inducing additional deformations. Thus the deformation is truncated using:</p>
<p>
<script type="math/tex; mode=display">\vec{u}_{t_{ij}} =
-\frac{1}{k_t}\left(\vec{F}_{t_{ij}} \sqrt{\frac{2R}{\delta_{ij}}} + \gamma_t
m_{\text{eff}}\vec{v}_{t_{ij}}\right) \, .</script>
</p>
<p>Considering that each particle $i$ interact with all the particles $j$ is in touch with , the total resultant force on particle $i$ is then computed by summing the contributions of all pair particles $(i,j)$. Considering that the grains are also under the effect of the gravitational field we obtain that the total force is given by</p>
<p>
<script type="math/tex; mode=display">\vec{F}_i^{\text{tot}}=m \vec{g} + \sum_j\left(\vec{F}_{n_{ij}}+\vec{F}_{t_{ij}}\right) \, ,</script>
</p>
<p>where $\vec{g}$ is the acceleration due to gravity.
Because particles has also rotational degree of freedoms, the total torque on particle $i$ is calculated using</p>
<p>
<script type="math/tex; mode=display">\vec{T}_i^{\text{tot}} = -R \sum_j \vec{n}_{ij}\times\vec{F}_{t_{ij}} \, .</script>
</p>
<p>$\vec{r}_i$ and angular velocities $\vec{\omega}_i$ for each particle $i$ at time step $n+1$,
We integrate in time the equations using leap-frog scheme with time step given by </p>
<p>
<script type="math/tex; mode=display">\delta t = 10^{-6}\,</script>
<script type="math/tex; mode=display">\vec{v}_i^{n+1} = \vec{v}_i^n + \frac{\delta t}{m}\vec{F}_i^{\text{tot}} \, , \qquad \vec{r}_i^{n+1} = \vec{r}_i^n + \delta t \vec{v}_i^{n+1}</script>
<script type="math/tex; mode=display">\vec{\omega}_i^{n+1} = \vec{\omega}_i^n + \frac{\delta t}{I_i}\vec{T}_i^{\text{tot}} \, ,</script>
</p>
<p>where $\vec{r}_i^{n},\vec{v}_i^{n},\vec{\omega}_i^{n}$ denotes respectively
the position, the speed and the rotational speed of the particle $i$ at time step
$n$, and $\delta t$ the time step size.</p>
<h4 id="simulation-results_2">Simulation results</h4>
<p><a href="https://openfpm.mpi-cbg.de/web/images/examples/8_DEM/DEM_velocity.mp4">Simulation video 1</a><br /></p>
<p>Key points:</p>
<ul>
<li>Method <code>DrawBox</code> of the class <code>DrawParticles</code> returns an iterator that can be used to create particles on a Cartesian grid with a given spacing (grid boundaries should be inside the simulation domain).</li>
<li>Domain decomposition uses a quadratic cost function assigned to <em>sub-domains</em> as a function of the number of <em>sub-sub-domains</em> via <code>addComputationCosts</code> of <code>vector_dist</code></li>
<li>Refine the domain decomposition instead of decomposing the domain from scratch via <code>getDecomposition().redecompose(...)</code> of <code>vector_dist</code>. Available only for ParMetis decomposition.</li>
<li>Iterating through the neighboring particles via <code>getNNIterator</code> of Verlet-list.</li>
<li>The method <code>updateVerlet</code> of <code>vector_dist</code> is used to update an existing Verlet-list after particles have changed their positions.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/8_DEM/main.cpp">Vector/8_DEM/main.cpp</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_8_DEM.html">Vector_8_DEM</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<p><a id="ex20"></a></p>
<h3 id="example-20-gpu-cuda-interoperability">Example 20: GPU CUDA interoperability</h3>
<p>This example shows how to access and operate data arrays in GPU kernels via memory pointers obtained from distributed data-structures.</p>
<p>Key points:</p>
<ul>
<li>The concept of coalesced memory access is shown for scalar property, vector and tensor properties.</li>
<li>Memory reallocation process and the concept of memory alignment is explained when extending a vector. </li>
<li>The method <code>getDeviceBuffer&lt;...&gt;()</code> of a serial property vector <code>vector</code> returned by <code>getPropVector</code> of parallel vector <code>vector_dist</code> is used to obtain an internal device pointer for the given property.</li>
</ul>
<p><em>The source code of the example <a href="https://github.com/mosaic-group/openfpm/blob/master/example/Vector/9_gpu_cuda_interop/main.cu">Vector/9_gpu_cuda_interop/main.cu</a>. The full doxygen documentation <a href="https://ppmcore.mpi-cbg.de/doxygen/openfpm/Vector_9_gpu_cuda_interop.html">9_gpu_cuda_interop</a></em>.</p>
<div style="clear:both;"></div>

<hr />
<div style="clear:both;"/>
</div></div>
            <div class="col-md-3 hidden-xs hidden-sm"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#examples-of-distributed-vector-usage">Examples of distributed vector usage</a></li>
        
            <li><a href="#vector-0-simple-vector-initialization">Vector 0: Simple vector initialization</a></li>
        
            <li><a href="#example-1-vector-ghost-layer">Example 1: Vector Ghost layer</a></li>
        
            <li><a href="#example-2-cell-lists-and-verlet-lists">Example 2: Cell-lists and Verlet-lists</a></li>
        
            <li><a href="#example-3-gpu-vector">Example 3: GPU vector</a></li>
        
            <li><a href="#example-4-hdf5-save-and-load">Example 4: HDF5 Save and load</a></li>
        
            <li><a href="#example-5-vector-expressions">Example 5: Vector expressions</a></li>
        
            <li><a href="#example-6-molecular-dynamics-with-lennard-jones-potential-cell-list">Example 6: Molecular Dynamics with Lennard-Jones potential (Cell-List)</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-verlet-list-13">Example 7: Molecular Dynamics with Lennard-Jones potential (Verlet-List) [1/3]</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-verlet-list-23">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric Verlet-List) [2/3]</a></li>
        
            <li><a href="#example-7-molecular-dynamics-with-lennard-jones-potential-symmetric-crs-verlet-list-33">Example 7: Molecular Dynamics with Lennard-Jones potential (Symmetric CRS Verlet-List) [3/3]</a></li>
        
            <li><a href="#example-8-molecular-dynamics-with-lennard-jones-potential-gpu">Example 8: Molecular Dynamics with Lennard-Jones potential (GPU)</a></li>
        
            <li><a href="#example-9-molecular-dynamics-with-lennard-jones-potential-gpu-optimized">Example 9: Molecular Dynamics with Lennard-Jones potential (GPU optimized)</a></li>
        
            <li><a href="#example-10-molecular-dynamics-with-lennard-jones-potential-particle-reordering">Example 10: Molecular Dynamics with Lennard-Jones potential (Particle reordering)</a></li>
        
            <li><a href="#example-11-molecular-dynamics-with-lennard-jones-potential-cell-list-reordering">Example 11: Molecular Dynamics with Lennard-Jones potential (Cell-list reordering)</a></li>
        
            <li><a href="#example-12-complex-properties-12">Example 12: Complex properties [1/2]</a></li>
        
            <li><a href="#example-13-complex-properties-22">Example 13: Complex properties [2/2]</a></li>
        
            <li><a href="#example-14-multiphase-cell-lists-and-verlet-lists">Example 14: Multiphase Cell-lists and Verlet-lists</a></li>
        
            <li><a href="#example-16-validation-and-debugging">Example 16: Validation and debugging</a></li>
        
            <li><a href="#example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-12">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU [1/2]</a></li>
        
            <li><a href="#example-17-smoothed-particle-hydrodynamics-sph-formulation-on-cpu-optimized-22">Example 17: Smoothed Particle Hydrodynamics (SPH) formulation on CPU: optimized [2/2]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-13">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU [1/3]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-optimized-23">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: optimized [2/3]</a></li>
        
            <li><a href="#example-18-smoothed-particle-hydrodynamics-sph-formulation-on-gpu-opetimized-33">Example 18: Smoothed Particle Hydrodynamics (SPH) formulation on GPU: opetimized [3/3]</a></li>
        
            <li><a href="#example-19-discrete-element-method-dem-simulation-of-the-avalanche-down-the-inclined-plane">Example 19: Discrete Element Method (DEM) simulation of the avalanche down the inclined plane</a></li>
        
            <li><a href="#example-20-gpu-cuda-interoperability">Example 20: GPU CUDA interoperability</a></li>
        
    
    
    </ul>
</div>

<!-- Developer notes:
  See the MkDocs documentation in https://www.mkdocs.org/dev-guide/themes/#page
  and the Jinja2 template API in https://tedboy.github.io/jinja2/index.html
--></div>
            
        </div>
        

        <footer class="footer">
           <div class="container">
              <p class="text-muted alignleft">
                  Developed by <a href = "mailto: yaskovet@mpi-cbg.de">Serhii Yaskovets</a> at
                  <a href="https://tu-dresden.de/ing/informatik/ki/wr">TUD</a>,
                  <a href="https://www.mpi-cbg.de/research/researchgroups/currentgroups/ivo-sbalzarini/group-members">MPI-CBG</a></p>
           </div>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
        <script src="../js/retina.min.js"></script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../search/main.js"></script>
    </body>
</html>